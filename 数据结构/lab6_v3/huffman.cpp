#ifndef _HUFFMANTREE_CPP_
#define _HUFFMANTREE_CPP_
//哈夫曼树 ：分配连续存储空间存储树 

#include <stdio.h>
#include <stdlib.h>

//编码的最大长度 
#define MCL 30 
//定义叶节点数,8bit的unsigned char 
#define n 256
//定义结点总数，2n-1 
#define m 511 

// 改为三叉链表
typedef struct HTNode{
	long w; 
	struct HTNode * parent,* lchild, * rchild;
} HTNode; 


typedef struct {
	unsigned code; //前面都是0，最后len位是编码 
	int len;   //编码长度 
} HCode;      //哈夫曼编码表

void printHtree1(HTNode ht[]); //函数声明 

/*** 以下代码哈夫曼树生成 ***/
//构造哈夫曼树/二叉树,输入长度为n=256的权向量w（每个字符出现的次数） ，返回树根的下标 
int createHTree(HTNode ht[], long* w) {
	long allw = 0;
	int numZero = 0;
	for (int i = 0; i < m; ++i) {
		ht[i].parent = ht[i].lchild = ht[i].rchild = NULL;  //ps
		ht[i].w = 0;
		if (i < n) {
			ht[i].w = w[i];
			if (w[i] == 0) numZero++; //统计没出现的字符个数 
			allw += w[i];
		}
	} //初始化哈夫曼树，每个结点构成一棵树 

	int i = n, j;
	long min1, min2;
	while (i < m - numZero) {
		min1 = min2 = allw + 10; //设置最大的w值 
		unsigned pos1, pos2;
		for (j = 0; j < i; j++) {
			if (ht[j].w == 0) //忽略权值为0的结点 
				continue;
			if (ht[j].parent == NULL) 
				if (ht[j].w < min1) {
					pos2 = pos1;
					min2 = min1;
					pos1 = j;
					min1 = ht[j].w;
				} //min1<min2,找到比min1更小的ht[j].w，那么min1替代min2， ht[j].w替代min1
				else {
					if (ht[j].w < min2) { //min1 <= ht[j].w < min2 
						pos2 = j;
						min2 = ht[j].w;
					}
				}
		}//内层for结束，找到pos1,pos2最小的两个权值，准备构造非叶节点  
		ht[i].lchild = ht + pos1; //小权值为左孩子
		ht[i].rchild = ht + pos2; 
		ht[i].w = min1 + min2;
		ht[pos1].parent = ht[pos2].parent = ht + i;  
		i++;
	}
	return m - numZero - 1;//返回根的下标 
}

//给定二叉树（结构体数组首地址）t以及根结点的下标ridx，遍历二叉树 (先序遍历）
/* 
void printHtree0(HTNode t[], int ridx) {
	if (ridx >= 0) { //递归出口 
		if (t[ridx].w > 0)
			printf("%3d->%5d\n", ridx < n ? t[ridx].id : t[ridx].id + n, t[ridx].w);
		printHtree0(t, t[ridx].lchild);
		printHtree0(t, t[ridx].rchild);
	}
}*/

/*
//直接当数组打印出来，调试用
void printHtree1(HTNode ht[]){
	printf("\n哈夫曼树(数组次序)：\n");
	for(int i=0;i<m;++i)
		if (i<n)
			printf("%2x %3d -> %5d => p:%3d lc:%3d rc:%3d\n",ht[i].id,ht[i].id, ht[i].w, ht[i].parent, ht[i].lchild,ht[i].rchild);
		else
			printf("%2x %3d -> %5d => p:%3d lc:%3d rc:%3d\n",ht[i].id,ht[i].id+256, ht[i].w, ht[i].parent, ht[i].lchild,ht[i].rchild);
}
*/

/*** 以下代码分析文件和从文件中生成哈夫曼编码表 ***/
//从filename中二进制读取字符，统计每个字符出现的次数，写入w并返回 
//w数组长度为256，如果字符不足256，那么没出现的字符权值为0  
unsigned char* parseFile(const char filename[], long* w, long* fsize) {
	FILE* fp = fopen(filename, "rb");
	if (fp == NULL) {
		printf("无法打开文件!\n");
		exit(0);
	}
	fseek(fp, 0, SEEK_END); // fp定位到文件尾 
	*fsize = ftell(fp); //计算fp相对于文件头的偏移
	rewind(fp); //将fp移动回去 
	unsigned char* dataArray;
	dataArray = (unsigned char*)malloc(sizeof(unsigned char) * (*fsize));
	if (!dataArray) {
		printf("文件太大，内存不够，读入错误!\n");
		exit(0);
	}
	fread(dataArray, sizeof(unsigned char), *fsize, fp); //读取待压缩文件
	fclose(fp); //关闭 fp  

	for (int i = 0; i < n; ++i) // 初始全置0 
		w[i] = 0;

	for (int i = 0; i < *fsize; ++i) // 如果对应字符出现则权值+1 
		w[dataArray[i]]++;

	return dataArray;
}

//输入任何字符c，得到它的哈夫曼编码, 被genHCodes()调用 
void getCode(HTNode ht[], int c, unsigned* code1, int* clen1) {
	int clen = 0;        //编码长度 
	unsigned code = 0;   //编码 

	int size = sizeof(code);  //编码的最大bits数 
	unsigned mask = 1 << (size * 8 - 1); //最高位为1其它为0，用来设置最高位为1 

	int parent = ht[c].parent - ht; 
	while (parent >= 0) {
		code = code >> 1;
		ht[parent].lchild - ht == c ? code : (code = code | mask); //右孩子为1，左孩子为0 
		clen++;
		c = parent;
		parent = ht[c].parent - ht; 
	}

	//code的前面clen位是哈夫曼编码，将其移动到最后
	code = code >> (size * 8 - clen);
	//printf("0x%x-%d\n",code,clen);
	*code1 = code;  //返回值 
	*clen1 = clen;  //返回值 
}

//从哈夫曼树ht生成完整的编码表hc，输出hc为encode()的输入参数 
void genHCodes(HCode hc[], HTNode ht[]) {
	for (int i = 0; i < n; ++i)
		if (ht[i].w > 0)
			getCode(ht, i, &(hc[i].code), &(hc[i].len));
}

/*** 以下为编解码实现 ***/
//编码,原长olen的内容orgi，压缩编码后为长nlen的内容newc，需要利用编码表hc 
void encode(unsigned char* orgi, long olen, unsigned char* newc, long* nlen, HCode hc[]) {
	long i = 0; //orgi的下标 
	long j = 0; //newc的下标 
	newc[j] = 0;
	unsigned code;
	int len;
	int usedbits = 0; //newc[j]中被占用的bits数 
	while (i < olen) {//对原始数据逐个字符处理 
		int idx = orgi[i]; //获得hc下标
		code = hc[idx].code;
		len = hc[idx].len;
		while (len + usedbits >= 8) {//code需要左移usedbits长的一段，然后和newc[j]位或操作 
			unsigned code1 = code >> len + usedbits - 8;
			newc[j] = newc[j] | code1; //填满前一个编码字符 
			len = len + usedbits - 8;      //code现在有效长度
			usedbits = 0;
			newc[++j] = 0;
			//printf("\n编码的第 %d 个字符为：#%2x\n",j-1,newc[j-1]);
		}//循环，使得len+usedbits < 8
		//将code的前面各位清0,因为有效位是len
		code = code & ((1 << len) - 1); //code和后面k个1，其它全为0的数据进行与，保留后面len位 
		code = code << 8 - len - usedbits;//向前移动若干位 
		newc[j] = newc[j] | code;
		usedbits = len + usedbits;
		i++;
	}
	*nlen = j + 1;
}

//生成和保存压缩文件,被压缩文件fin，指定文件名fout，将所用的哈夫曼树存入文件 
void zip(char fin[], char fout[]) {
	
	
	HTNode ht[m];   //结构体数组，表示哈夫曼树 : id,w,parent,lchild,rchild，用于生成编码表和解压 
	HCode hc[n];    //结构体数组，表示哈夫曼编码表 :code,len，用于编码文件 
	long wDist[256]; //保存字符的分布（字符在文件中出现的次数） 
	long fsize;      //文件长度 
	//获取文件内容，分析待压缩文件，返回权值向量wDist,文件内容content和长度fsize 
	unsigned char* content = parseFile(fin, wDist, &fsize);

	// 生成压缩树（H树）		 
	int root = createHTree(ht, wDist); //root是哈夫曼树ht的根结点的下标 
	genHCodes(hc, ht);	//生成完整的编码表,用于编码文件 

	//下面的代码用于测试哈夫曼树 
	//printHtree1(ht); //将哈夫曼树按数组打印出来 	
	//printHtree0(ht,root); //先序遍历哈夫曼树 
	//saveTree(ht,root,"aa1.html"); //图形展示哈夫曼树 , 请先导入showgt.h
	// 开始压缩
	unsigned char* zipContent; //编码后的内容	
	long zipsize;//压缩后文件大小 
	zipContent = (unsigned char*)malloc(sizeof(unsigned char) * (fsize + 10000));//压缩后的文件可能更大，考虑将fsize扩大一点 
	if (!zipContent) {
		printf("文件太大，内存不够，读入错误!\n");
		exit(0);
	}
	encode(content, fsize, zipContent, &zipsize, hc); //编码后返回长度zipsize的内容zipContent 

	FILE* fp = fopen(fout, "wb");
	if (fp == NULL) {
		printf("无法打开写入文件!\n");
		exit(0);
	}
	long ht_size = sizeof(HTNode) * m;      //哈夫曼编码表的大小 
	fwrite(&ht_size, sizeof(ht_size), 1, fp);//保存哈夫曼树的大小
	fwrite(&zipsize, sizeof(zipsize), 1, fp);//保存编码内容的大小 
	fwrite(&fsize, sizeof(fsize), 1, fp);    //保存原始内容的大小 
	fwrite(&root, sizeof(root), 1, fp);      //保存哈夫曼树根节点的下标 
	fwrite(ht, sizeof(HTNode), m, fp);       //保存哈夫曼树 ，解码要用到 
	//printf("%d %d %d %d %lx\n",ht_size,zipsize,fsize,root,ht);
	HTNode *offset=ht;
	fwrite(&offset,sizeof(HTNode *),1,fp);   //保存数组首地址，用于解码时计算偏移量 

	fwrite(zipContent, sizeof(unsigned char), zipsize, fp);//保存编码后的内容 
	fclose(fp);

	free(zipContent);	//释放文件内容
	free(content);
	printf("压缩文件 %s 已经生成！\n", fout);
}

//读取压缩文件，解压 
void unzip(char zfile[], char ofile[]) {
	FILE* fp = fopen(zfile, "rb");
	if (fp == NULL) {
		printf("无法打开压缩文件进行读取!\n");
		exit(0);
	}
	long ht_size1, zipsize1, fsize1;
	int root; //树的根结点下标 
	fread(&ht_size1, sizeof(ht_size1), 1, fp); //哈夫曼树的大小(字节数） 
	fread(&zipsize1, sizeof(zipsize1), 1, fp); //压缩后内容的大小 
	fread(&fsize1, sizeof(fsize1), 1, fp);     //被压缩内容的大小 
	fread(&root, sizeof(root), 1, fp);         //哈夫曼树根的下标 
    
	unsigned char* zcontent = (unsigned char*)malloc(zipsize1);//存放读取的编码数据 
	unsigned char* ocontent = (unsigned char*)malloc(fsize1);//解码后的数据 
	HTNode ht1[m];
	fread(ht1, ht_size1, 1, fp);//读取哈夫曼树 
	//printf("%d %d %d %d %lx\n",ht_size1,zipsize1,fsize1,root,ht1);
	HTNode *offset;
	fread(&offset,sizeof(HTNode*),1,fp); //Huffman树的偏移量 

	fread(zcontent, zipsize1, 1, fp); //读取编码数据
	fclose(fp);

	fp = fopen(ofile, "wb");
	if (fp == NULL) {
		printf("无法打开解压后文件进行解压!\n");
		exit(0);
	}
    //偏移数组 
	for(int i=0;i<m;++i)
	{
		if(ht1[i].parent) ht1[i].parent+=ht1-offset;
		if(ht1[i].lchild) ht1[i].lchild+=ht1-offset;
		if(ht1[i].rchild) ht1[i].rchild+=ht1-offset;
		//printf("")
	} 
	int idx = root; //从根开始 
	int j, k = 0, i = 0;//zcontent的下标 k,ocontent的下标i 
	while (i < fsize1) {//依次写入解压后数据的每个字节 
		j = 128; //10000000 
		while (j > 0) {
			if ((zcontent[k] & j) > 0) { //向右走 1
				if (ht1[idx].rchild == NULL) {
					ocontent[i++] = idx; 
					idx = root;//解码了下一个字符的第一个bit 
					j = j << 1;
				}
				else
					idx = ht1[idx].rchild - ht1;
			}
			else {//向左走 0
				if (ht1[idx].lchild == NULL) {
					ocontent[i++] = idx;
					idx = root;//解码了下一个字符的第一个bit 
					j = j << 1;
				}
				else
					idx = ht1[idx].lchild - ht1;
			}
			j = j >> 1; //j控制while循环8次，求出zcontent[k]的每一位 
		}
		k++;//准备读取下一个字符 
	}

	fwrite(ocontent, fsize1, 1, fp);	// 将解压内容写入文件
	fclose(fp);
	free(ocontent);
	free(zcontent);
	printf("文件 %s 已经成功解压为 %s ！\n", zfile, ofile);
}

int check(char file1[], char file2[]){	// 返回1说明文件一样，返回0说明文件不一样
	FILE *fp1 = fopen(file1,"r"), *fp2 = fopen(file2,"r");
	unsigned fsize1,fsize2;
	fseek(fp1, 0, SEEK_END);	fseek(fp2, 0, SEEK_END);
	fsize1 = ftell(fp1);		fsize2 = ftell(fp2);
	rewind(fp1);				rewind(fp2);
	if(fsize1 != fsize2) return 0;
	char c1,c2;
	for(unsigned i = 0; i < fsize1; ++i){
		fread(&c1,1,1,fp1);		fread(&c2,1,1,fp2);
		if(c1 != c2) return printf("at fsize = %d, c1 is %d, c2 is %d\n",i,c1,c2);
	}
	fclose(fp1);				fclose(fp2);
	return 1;
}

int main() 
{
	// 操作
	zip("pic.png","pic.png.myzip");
	return 1;
}

#endif
